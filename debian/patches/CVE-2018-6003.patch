Backport of:

From c593ae84cfcde8fea45787e53950e0ac71e9ca97 Mon Sep 17 00:00:00 2001
From: Nikos Mavrogiannopoulos <nmav@redhat.com>
Date: Thu, 4 Jan 2018 10:52:05 +0100
Subject: _asn1_decode_simple_ber: restrict the levels of recursion to 3

On indefinite string decoding, setting a maximum level of recursions
protects the BER decoder from a stack exhaustion due to large amounts
of recursion.

Signed-off-by: Nikos Mavrogiannopoulos <nmav@redhat.com>
diff --git a/lib/decoding.c b/lib/decoding.c
index 38096a4..105ad35 100644
--- a/lib/decoding.c
+++ b/lib/decoding.c
@@ -43,6 +43,16 @@
 
 #define HAVE_TWO(x) (x>=2?1:0)
 
+#define DECODE_FLAG_HAVE_TAG 1
+#define DECODE_FLAG_INDEFINITE (1<<1)
+/* On indefinite string decoding, allow this maximum levels
+ * of recursion. Allowing infinite recursion, makes the BER
+ * decoder susceptible to stack exhaustion due to that recursion.
+ */
+#define DECODE_FLAG_LEVEL1 (1<<2)
+#define DECODE_FLAG_LEVEL2 (1<<3)
+#define DECODE_FLAG_LEVEL3 (1<<4)
+
 #define DECR_LEN(l, s) do { \
 	  l -= s; \
 	  if (l < 0) { \
@@ -2210,25 +2220,27 @@ static int append(uint8_t **dst, unsigned *dst_size, const unsigned char *src, u
   return ASN1_SUCCESS;
 }
 
-/**
- * asn1_decode_simple_ber:
+/*-
+ * _asn1_decode_simple_ber:
  * @etype: The type of the string to be encoded (ASN1_ETYPE_)
  * @der: the encoded string
  * @_der_len: the bytes of the encoded string
  * @str: a pointer to the data
  * @str_len: the length of the data
  * @ber_len: the total length occupied by BER (may be %NULL)
+ * @have_tag: whether a DER tag is included
  *
  * Decodes a BER encoded type. The output is an allocated value 
  * of the data. This decodes BER STRINGS only. Other types are
  * decoded as DER.
  *
  * Returns: %ASN1_SUCCESS if successful or an error value.
- **/
-int
-asn1_decode_simple_ber (unsigned int etype, const unsigned char *der,
+ -*/
+static int
+_asn1_decode_simple_ber (unsigned int etype, const unsigned char *der,
 			unsigned int _der_len, unsigned char **str,
-			unsigned int *str_len, unsigned int *ber_len)
+			unsigned int *str_len, unsigned int *ber_len,
+			unsigned dflags)
 {
   int tag_len, len_len;
   const unsigned char *p;
@@ -2283,7 +2295,8 @@ asn1_decode_simple_ber (unsigned int etype, const unsigned char *der,
   if (der_len <= 0)
     return ASN1_DER_ERROR;
 
-  if (class == ASN1_CLASS_STRUCTURED && ETYPE_IS_STRING(etype))
+  if ((((dflags & DECODE_FLAG_INDEFINITE) || class == ASN1_CLASS_STRUCTURED) && ETYPE_IS_STRING(etype)) &&
+      !(dflags & DECODE_FLAG_LEVEL3))
     {
 
       len_len = 1;
@@ -2304,8 +2317,17 @@ asn1_decode_simple_ber (unsigned int etype, const unsigned char *der,
       do
         {
           unsigned tmp_len;
+          unsigned flags = DECODE_FLAG_HAVE_TAG;
+
+          if (dflags & DECODE_FLAG_LEVEL1)
+                flags |= DECODE_FLAG_LEVEL2;
+          else if (dflags & DECODE_FLAG_LEVEL2)
+		flags |= DECODE_FLAG_LEVEL3;
+	  else
+		flags |= DECODE_FLAG_LEVEL1;
 
-          ret = asn1_decode_simple_ber(etype, p, der_len, &out, &out_len, &tmp_len);
+          ret = _asn1_decode_simple_ber(etype, p, der_len, &out, &out_len, &tmp_len,
+                                           flags);
           if (ret != ASN1_SUCCESS)
             {
               free(total);
@@ -2370,3 +2392,27 @@ asn1_decode_simple_ber (unsigned int etype, const unsigned char *der,
 
   return ASN1_SUCCESS;
 }
+
+
+/**
+ * asn1_decode_simple_ber:
+ * @etype: The type of the string to be encoded (ASN1_ETYPE_)
+ * @der: the encoded string
+ * @_der_len: the bytes of the encoded string
+ * @str: a pointer to the data
+ * @str_len: the length of the data
+ * @ber_len: the total length occupied by BER (may be %NULL)
+ *
+ * Decodes a BER encoded type. The output is an allocated value 
+ * of the data. This decodes BER STRINGS only. Other types are
+ * decoded as DER.
+ *
+ * Returns: %ASN1_SUCCESS if successful or an error value.
+ **/
+int
+asn1_decode_simple_ber (unsigned int etype, const unsigned char *der,
+			unsigned int _der_len, unsigned char **str,
+			unsigned int *str_len, unsigned int *ber_len)
+{
+  return _asn1_decode_simple_ber(etype, der, _der_len, str, str_len, ber_len, DECODE_FLAG_HAVE_TAG);
+}
